<div class="wrapper">
<h1 id="zero-to-api-in-ten-minutes-with-amazon-api-gateway-and-aws-lambda">Zero to API in Ten Minutes, with Amazon API Gateway and AWS Lambda</h1>

<p>Servers are annoying, even in the age of cloud services.
You choose them, provision them, configure them, deploy to them,
monitor them, meter them.  You decide when to add or remove them.
And at the end of the month, you need to pay for what you used,
and what you didn’t.</p>

<p>There is quite a lot to be said for a serverless architecture.
It’s the quickest and cheapest way off the ground, for the hobbyist and
scrappy startup alike.  The explosion of SaaS in recent years has
paved the way for the concept of “servers” to be someone else’s problem.</p>

<p>But there are things only servers can do properly.  Cryptographic
secrets, for instance, can’t be fully protected in browsers or mobile
apps.  Servers provide stronger assurances that a process will be run to
completion.  And browsers, though fast and reliable, are slow as hell
and maddeningly uncontrollable.</p>

<h2 id="enter-amazon">Enter Amazon</h2>

<p>It was in this climate that
<a href="https://aws.amazon.com">Amazon Web Services</a>,
industry leaders in managing large pools of computing resources,
introduced the
<a href="https://aws.amazon.com/lambda">Lambda</a> platform for ephemeral
computing.  Users could supply code, and based on certain
triggers it would run <em>somewhere</em>, not immediately but
milliseconds-soon.  There were plenty of limitations at first –
a 60 second execution limit, to name but one –
but the service offered pure, serverless, on-demand computing, and
at <a href="https://aws.amazon.com/lambda/pricing/">prices that small-to-medium businesses had no hope of
matching themselves</a>.</p>

<p>Not much later, the Lambda system was integrated into
<a href="https://aws.amazon.com/api-gateway/">Amazon API Gateway</a>,
closing the loop on serverless API architecture and
<a href="https://aws.amazon.com/api-gateway/pricing/">offering similar fire-sale
prices</a> to Lambda.</p>

<p>At this point, API Gateway and Lambda are mature and production-tested
products, and as long as your API requirements don’t include white-hot
response times or long-lived requests, they’re a very attractive option
for the startup on a tech-spend diet.</p>

<p>The great news is that it’s not only cheap to stand up an API with API
Gateway, it’s also quick work.  Ten minutes if you’re copy-pasting,
half an hour if you’re a good typist.</p>

<p>The work can be broadly divided into three steps:</p>

<ul>
  <li>Write a request handler</li>
  <li>Install it as a Lambda</li>
  <li>Create an API in API Gateway, and connect the Lambda to a resource and
method</li>
</ul>

<p>Let’s dive in.</p>

<h2 id="write-the-request-handler">Write the Request Handler</h2>

<p>In this article, we’ll stick to the AWS Lambda default of JavaScript,
so we’ll need a working Node.js installation.  On a Mac with
<a href="http://brew.sh/">Homebrew</a>, run <code>brew update; brew install node</code>.</p>

<p>We’ll start by writing a request handler in plain JavaScript.
Let’s make a skeleton project to hold our request handler:</p>

<pre><code>mkdir myNewApi
cd myNewApi
mkdir lib test
touch lib/my_new_api.js test/my_new_api_test.js index.js package.json
</code></pre>

<p>In <code>package.json</code>, we have the usual content, as well as a script to generate
a <code>.zip</code> from the contents of <code>myNewApi</code>.</p>

<pre><code>{
  "name": "myNewApi",
  "version": "0.0.1",
  "description": "Wicked awesome test API",
  "author": "pete gamache &lt;pete@appcues.com&gt;",
  "main": "index.js",

  "dependencies": {
  },

  "devDependencies": {
    "chai": "*",
    "mocha": "*"
  },

  "scripts": {
    "zip": "zip -r ../myNewApi.zip *"
  }
}
</code></pre>

<p>Our <code>index.js</code> holds what we might deem “controller” code.  It contains the
handler which AWS invokes as the main function of the Lambda.  We load a
config file and our main code, and in <code>exports.handler</code> we invoke a
function we’re about to write, <code>handleRequest</code>, passing it <code>event</code> (a JS
object containing the JSON-decoded request body), <code>config</code> (a JS object
loaded from our config file), and a Node-style callback of the form
<code>function (err, responseObject)</code>.</p>

<pre><code>var package = require("./package.json");
var myNewApi = require("./lib/my_new_api.js");

console.log("loaded " + package.name + ", version " + package.version);

exports.handler = function (event, context) {
  myNewApi.handleRequest(event, context.done);
}
</code></pre>

<p>In <code>lib/my_new_api.js</code>, we place a request handler which invokes its
given callback with a wrapped version of its input data:</p>

<pre><code>exports.handleRequest = function (requestData, callback) {
  var responseData = {received_as_input: requestData};
  callback(null, responseData);
}
</code></pre>

<p>We are civilized humans in the twenty-first century.
We shall write a test.
In <code>test/my_new_api_test.js</code>:</p>

<pre><code>var assert = require("chai").assert;
var myNewApi = require("../lib/my_new_api.js");

describe("myNewApi", function () {
  it("exports handleRequest", function () {
    assert.typeOf(myNewApi.handleRequest, "function");
  });
});
</code></pre>

<p>With the files in place, run <code>npm install</code> to ensure all dependencies
are installed.</p>

<p>At this point, you should be able to type <code>mocha</code> at the command prompt
and see 1 passing test.</p>

<h2 id="set-up-the-lambda">Set up the Lambda</h2>

<p>Now it’s time to take the code we just wrote and install it as a Lambda.
This can be done with the AWS API, but here we will do it using the AWS
Console on the web.  Log into AWS, click on AWS Lambda, and click past
any “Get Started” or “Select blueprint” crap.  We’re aiming for “Configure
function”.</p>

<h3 id="create-and-configure-the-lambda">Create and configure the Lambda</h3>

<p>Enter a camelCased name for your function, along with a description of
what it does.  Keep Node.js selected as our runtime.  Here’s an example.</p>

<p><img src="lambda-configure-function.jpg" alt="screenshot of Configure function" /></p>

<pre><code>npm run zip
</code></pre>

<p>And <code>myNewApi.zip</code> will appear alongside the <code>myNewApi/</code> directory.
Be sure you’ve run <code>npm install</code> beforehand!</p>

<p>The default Lambda function handler <code>index.handler</code> does not need
adjustment, because we set up our <code>index.js</code> to match.</p>

<p>For the “Role”, we need to set up a Lambda execution role.  Select
“Create New Role &gt; Basic Execution Role” from the dropdown menu, and
follow the instructions to create the role.</p>

<p><img src="lambda-create-role.jpg" alt="screenshot of Lambda role creation" /></p>

<p>The advanced settings need no tweaking, but for more intensive tasks,
the RAM and execution time limit can be increased there.</p>

<p>Click on “Create Function” to save the Lambda to AWS.</p>

<h3 id="test-the-lambda">Test the Lambda</h3>

<p>Once we’ve saved the Lambda, a Test button appears, allowing us to send
a dummy payload to the function and observe its output.  With the
default test event, we should see results like the following:</p>

<p><img src="lambda-test-output.jpg" alt="screenshot of JSON output, with input data under the key
&quot;received_as_input&quot;" /></p>

<h2 id="set-up-api-gateway">Set up API Gateway</h2>

<p>OK.  The Lambda’s in place, and we’ve watched it work.
It’s time to set up API Gateway, so we
navigate to that section of our AWS console.</p>

<h3 id="create-the-api">Create the API</h3>

<p>Create a new API.  Give it a name and a description.</p>

<p><img src="apigateway-new-api.jpg" alt="screenshot of Create API page" /></p>

<p>We’ll eventually land on the Resources page, where you can create
resources (paths) and methods on those resources.
<img src="apigateway-fresh-api.jpg" alt="screenshot of fresh API page" /></p>

<h3 id="create-a-method">Create a method</h3>

<p>A “method” in API Gateway terms is a combination of a “resource” (path)
and an HTTP method to which it responds.  API Gateway methods are
the basic building blocks of the API.</p>

<p>Click on “Create Method”.  Let’s use POST as an example, so we can show
off more features than GET.  On the following screen, select “Lambda
function” as the integration type, and enter the details for the Lambda
we just created.</p>

<p><img src="apigateway-post-setup.jpg" alt="screenshot of Create Method page" /></p>

<p>AWS will ask for permission to grant API Gateway
access to the Lambda; say yes.</p>

<p><img src="apigateway-invoke-permission.jpg" alt="screenshot of AWS asking for permission to invoke
Lambda" /></p>

<p>We’ll land on the <code>/ - POST</code> Method Execution page.  There’s a lot of
important functionality in this screen, including input and output
validation and JSON transformations.  (We won’t get too deep in this
demonstration, but you should play around here later.)</p>

<p><img src="apigateway-post-method-execution.jpg" alt="screenshot of / POST method page" /></p>

<h3 id="test-the-method">Test the method</h3>

<p>That lightning-bolt Test icon looks too good.  Let’s click it.</p>

<p><img src="apigateway-test.jpg" alt="screenshot of method test" /></p>

<p>Enter <code>{"hello": "world"}</code> as the request payload,
and ensure that the response body is:</p>

<pre><code>{
  "received_as_input": {
    "hello": "world"
  }
}
</code></pre>

<p><img src="apigateway-test-results.jpg" alt="screenshot of API Gateway test results" /></p>

<p>We are now one step away from having a real API.  Click the “Deploy API”
button in the sidebar.  Create a new stage.  Call it something.  Hit
“Deploy”.</p>

<p><img src="apigateway-deploy.jpg" alt="screenshot of API Gateway Deploy modal" /></p>

<p>You’ll see a url like
<code>https://f8fenu11tf.execute-api.us-west-2.amazonaws.com/prod</code> on the
next page.  Let’s test it out on the command line:</p>

<pre><code>$ curl -X POST -d '{"hi":"mom"}' https://f8fenu11tf.execute-api.us-west-2.amazonaws.com/prod
{"received_as_input":{"hi":"mom"}}
</code></pre>

<p>Congratulations! We have an API.</p>

<h2 id="tips-tricks-and-gotchas">Tips, tricks, and gotchas</h2>

<ul>
  <li>
    <p><a href="http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html">Mapping templates</a>,
accessible in the Request Integration and Response Integration screens,
may be used to transform request or response data, including adding
request metadata from Amazon to request data from the user.  One
particularly compelling use case is selecting different config
parameters based on the value of the <code>stage</code> parameter.</p>

    <p>Be aware that input mapping templates match on content type, and thus
depend on a properly-set <code>Content-Type</code> request
header.  Also be aware that mapping templates can turn nulls into blank
strings, depending on how they’re put together, so make sure your
request handling code is prepared for that.</p>
  </li>
  <li>
    <p><a href="http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-cors.html">Cross-origin resource sharing</a>
can be enabled if you’d like to use your API from the browser without
setting up a custom domain for it.  It involves creating an <code>OPTIONS</code>
endpoint alongside your <code>POST</code> endpoint, and installing some access
control headers.</p>
  </li>
  <li>
    <p><a href="http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-model.html">Request and response models</a>
allow the validation of input and output against
<a href="http://json-schema.org">JSON Schemas</a>.  This provides the opportunity
for rudimentary input checking outside the Lambda, for example.</p>
  </li>
  <li>
    <p>API Gateway methods can be connected to not only a specific lambda,
but <a href="http://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">a specific version of a
Lambda</a>.
This is a convenient way to pin
an API Gateway stage to a precise version of a Lambda, for instance
ensuring that the <code>prod</code> stage always points to the same code,
regardless of further changes to the Lambda.  To use a specific version
of a Lambda, paste that version’s ARN into the API Gateway
Create Method screen and deploy or redeploy the stages which should
use it.</p>
  </li>
  <li>
    <p><a href="https://github.com/jaws-framework/JAWS">The JAWS Framework</a> provides a
convenient way to structure and maintain
serverless APIs written with Lambda and API Gateway.  It’s still a young
project, but it’s gaining momentum quickly, and the improved source
code management and scriptability make it an increasingly good choice
for managing your serverless API.  And for Python, check out the
emerging <a href="https://github.com/braahyan/PAWS">PAWS Framework</a>, heavily
inspired by JAWS.</p>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>We’ve only just scratched the surface of what API Gateway can do.
But we’ve still managed to set up an API in a matter of minutes,
including deployment, without provisioning a single server.
And it costs around five dollars per million requests.</p>

<p>If that sounds like a good fit for you and your project, give it a spin!</p>

<h2 id="about-the-author">About the Author</h2>

<p>Pete Gamache is Head of Engineering at <a href="http://appcues.com">Appcues</a>,
an onboarding and user guides startup that moves fast and fixes things.
He is a proud API geek and enjoys living in the future.
<a href="https://twitter.com/gamache">Follow him on Twitter</a>.</p>


</div>

